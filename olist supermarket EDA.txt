Brazilian E-Commerce Public Dataset by Olist
Welcome! This is a Brazilian ecommerce public dataset of orders made at Olist Store. The dataset has information of 100k orders from 2016 to 2018 made at multiple marketplaces in Brazil. Its features allows viewing an order from multiple dimensions: from order status, price, payment and freight performance to customer location, product attributes and finally reviews written by customers. We also released a geolocation dataset that relates Brazilian zip codes to lat/lng coordinates.

This is real commercial data, it has been anonymised, and references to the companies and partners in the review text have been replaced with the names of Game of Thrones great houses.

Join it With the Marketing Funnel by Olist
We have also released a Marketing Funnel Dataset. You may join both datasets and see an order from Marketing perspective now!

Instructions on joining are available on this Kernel.

Context
This dataset was generously provided by Olist, the largest department store in Brazilian marketplaces. Olist connects small businesses from all over Brazil to channels without hassle and with a single contract. Those merchants are able to sell their products through the Olist Store and ship them directly to the customers using Olist logistics partners. See more on our website: www.olist.com

After a customer purchases the product from Olist Store a seller gets notified to fulfill that order. Once the customer receives the product, or the estimated delivery date is due, the customer gets a satisfaction survey by email where he can give a note for the purchase experience and write down some comments.

Attention
An order might have multiple items.
Each item might be fulfilled by a distinct seller.
All text identifying stores and partners where replaced by the names of Game of Thrones great houses.



--Q1- from which city most of the order_status is delivered.
select c.customer_city, count(customer_city) as count_of_city from customer as c
left join orders as o
on o.customer_id=c.customer_id
where order_status = 'delivered'
group by c.customer_city
order by count_of_city desc limit 10 

--Q2. which customer_id placed the most orders. cutomer, orders
select c.customer_unique_id, count(c.customer_unique_id) as count from customer as c
left join orders as o
on o.customer_id=c.customer_id
where order_status = 'delivered'
group by c.customer_unique_id
order by count desc limit 10 

-----------What are our favourite customer.(most purchse in terms of price excluding freight price).
select c.customer_id,c.customer_city, sum(oi.price) as total_price from customer as c
left join orders as o
on c.customer_id=o.customer_id
left join order_items as oi
on o.order_id= oi.order_id
where o.order_status = 'delivered'
group by c.customer_id,c.customer_city
order by total_price desc limit 10

-- Q3.how many orders were not delivred/cancelled.

with t1 as 
	(select count(order_status) as total_orders from orders),
t2 as
 	(select count(*) as no_of_order_cancelled from orders 
	where order_status = 'canceled')
select total_orders,no_of_order_cancelled/total_orders :: decimal as order_cancelled_percentage 
	from t1,t2

------also take customer id , customer city.
select c.customer_id,c.customer_city, count(order_status) as order_cancelled from customer as c
left join orders as o
on o.customer_id=c.customer_id
left join order_items as oi
on oi.order_id= o.order_id
where order_status = 'canceled'
group by c.customer_city,c.customer_id
having count(order_status) > 1
order by order_cancelled desc 

--Q4.merge product and producttranslation and save it as view.
create view product as
    select p.product_id, pt.product_category_name_english
    from products as p
    join productname_translation as pt on pt.product_category_name = p.product_category_name
select *
from product

--renamed column
alter table product
rename product_category_name_english to product_name

----find out which product are in demand in terms of sale.
select p.product_name, count(o.order_status) as product_order, round(sum(oi.price)::decimal,2) total_sales from order_items as oi
inner join product as p
on p.product_id=oi.product_id
inner join orders as o
on o.order_id =oi.order_id
group by p.product_name
order by total_sales desc,  product_order desc

--extract date
alter table orders
add column order_purchase_date date;
update orders
set order_purchase_date = cast(left(order_purchase_timestamp,position(' ' in order_purchase_timestamp ) ) as date)

alter table orders
add column order_delivered_date date;
update orders
set order_delivered_date = cast(left(order_delivered_customer_date,position(' ' in order_purchase_timestamp ) ) as date)

--Q5. is there any order with same day delivery.
select sum(same_day_delivered) as no_same_day_delivery from
(select o1.order_status,o1.order_purchase_date, o2.order_delivered_date, count(*) as same_day_delivered
from orders as o1
left join orders as o2 
on o2.order_delivered_date = o1.order_purchase_date where o1.order_status = 'delivered'
group by o1.order_status,o1.order_purchase_date, o2.order_delivered_date) as x

--Q6. most of the payment done by ? 
select payment_type, count(payment_value) 
from order_payment
group by payment_type
order by count desc

--Q7. from which  seller_city most of the items purchased.
select si.seller_city, count(oi.*) as total_order from seller_info as si
inner join order_items as oi
on si.seller_id = oi.seller_id
group by si.seller_city
order by total_order desc


--Q8. profit/loss - find out trend / order placed yearwise.

alter table orders 
add column year numeric;
update orders
set year = extract(year from order_purchase_date)

select o.year, round(sum(op.payment_value) :: decimal,2) as total_sales
from orders as o
inner join order_payment as op
on op.order_id = o.order_id
group by o.year
























